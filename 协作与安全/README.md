# 线程安全

线程安全性是并发代码最重要也是最基本的要求，我们不应容忍大部分时候可以正确运行，但是在偶然情况下会出错的并发程序。多线程的核心矛盾即为**竞态条件**，即多个线程同时读写某个字段；而竞态条件下多线程争抢的资源就是**竞态资源**，或者说是**临界资源**。**临界区**即是设计读写竞态资源的代码片。线程如果都各自干活互不搭理的话自然相安无事，但多数情况下线程直接需要打交道，而且需要分享共享资源，那么这个时候最核心的就是线程安全了。当多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替运行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获取正确的结果，那这个对象是线程安全的。

上文已经提到，共享可变状态是造成线程不安全的唯一原因，那么为了解决线程安全性问题，可以先从避免共享状态或者避免可变状态入手。所有的线程安全性问题，都可以归结于同一个原因: 共享的可变状态。首先来看状态的共享，在 Java 中，如果类的某个域被声明为 public，或者通过 public 方法返回了某个 private 域的引用，那么这个域就可以被其它对象访问到，可以认为基于该类创建的对象，共享了其状态。一旦状态被共享，宿主对象就失去了状态的完全控制权，你无法预知其它对象会对共享状态做怎样的误操作。状态的可变性问题则来源于我们将在内存模型章节讨论的可见性、原子性与有序性问题。

# 线程的活跃性

遇到活跃性问题的并发程序，被称为(Poor Concurrency)应用程序，活跃性问题可能有很多原因引起:

- 线程开销：线程虽然比进程轻量，但是线程的管理仍然需要消耗一定的系统资源。比如线程上下文切换，需要 5000~10000 个时钟周期，大约是几微秒，如果线程上下文切换过于频繁，就会对活跃性造成影响。

- 阻塞：当线程被不恰当地置为阻塞状态时，后续的指令得不到执行，于是就会出现活跃性问题。

- 死锁：死锁是最常见的活跃性风险。当两个线程互相等待对方持有的资源时，就会发生死锁。不恰当的加锁解锁顺序，以及错误的资源管理策略，都有可能导致死锁。死锁往往出现在最糟糕的时候：高负载的情形。

- 活锁：当线程不断地重试某个失败的操作时，就会发生活锁。此时线程虽然不会被阻塞，但也不能继续执行。

要避免线程活跃性问题，需要我们对并发机制有深刻了解，并养成良好的并发编程习惯。常见的解决并发活跃性问题的手段有:

- 避免使用锁。这是釜底抽薪、从源头解决的问题的办法。没有买卖就没有伤害，没有锁就不会陷入单线程执行模式，就不会有线程活跃性问题。可以使用上文提到的避免可变状态、避免共享状态等手段，来规避对锁的使用。

- 降低锁的粒度。如果加锁不可避免，那么可以尝试降低锁的粒度，只在确实需要使用锁的地方才使用它。比如可以在一个方法内部，只对其中的某几行代码，引入 synchornized 对代码块进行同步。

- 加上超时限制。并发程序可能会以出乎意料的方式，陷入长时间的锁等待，甚至是死锁。作为止血方案，可以使用显示锁(Lock 类)，并指定超时时限(Timeout), 在超过该时间之后就返回一个失败信息，避免永久等待。
