# 反应式编程

反应式编程是一种以异步处理数据流为中心思想的编程范式，这个范式存在已久，不是新概念，就像面向过程、面向对象编程、函数式编程等范式。Reactive 模型最核心的是线程和消息管道。线程用于侦听事件，消息管道用于线程之间通信不同的消息。

# 反应式宣言

[反应式宣言](https://www.reactivemanifesto.org/zh-CN) 是一切反应式概念的根源理论基础。描述了反应式系统（reactive systems）应该具备的四个关键属性：Responsive（灵敏的）、Resilient（可故障恢复的）、Elastic（可伸缩的）、Message Driven（消息驱动的）。

![反应式因素](https://s2.ax1x.com/2019/11/25/MvR9EV.png)

- **Responsive（灵敏的）**：只要有可能，系统就会及时响应。灵敏性是系统可用性的基石，除此之外，灵敏性也意味着系统的问题可以被快速地探测和解决。具有灵敏性的系统关注做出快速和一致的响应，提供可靠和一致的服务质量。

- **Resilient（可故障恢复的）**：在出现故障时，系统仍然可以保持响应。一个不具可恢复性的系统一旦出现故障，就会变得无法正常响应。可恢复性可以通过复制、围控、隔离和委派等方式实现。在可恢复性的系统中，故障被包含在每个组件中，各组件之间相互隔离，从而允许系统的某些部分出故障并且在不连累整个系统的前提下进行恢复。

- **Elastic（可伸缩的）**：在不同的工作负载下，系统保持响应。系统可以根据输入的工作负载，动态地增加或减少系统使用的资源。这意味着系统在设计上可以通过分片、复制等途径来动态申请系统资源并进行负载均衡，从而去中心化，避免节点瓶颈。

- **Message Driven（消息驱动的）**：反应式系统依赖异步消息传递机制，从而在组件之间建立边界，这些边界可以保证组件之间的松耦合、隔离性、位置透明性，还提供了以消息的形式把故障委派出去的手段。

- **Failures at messages**：在 Reactive 编程中，我们通常需要处理流式的信息，我们最不希望看到的是突然抛出一个异常，然后处理过程终止了。理想的解决办法是我们记下这个错误，然后开始执行某种重试或恢复的逻辑。在 Reactive Streams 中，异常是一等公民，异常不会被粗鲁地抛出，错误处理是正式建立在 Reactive Streams API 规范之内的。

- **Back-pressure**：中文一般翻译成“背压”、“回压”，意思是当消费端的消费能力跟不上生产端的生产速度时，消息流下游的消费方对上游的生产方说：“我喝饱了，请你慢点”。在 Reactive 的世界里，我们希望下游的消费方可以有某种机制按需请求一定数量的消息来消费（这类似消息队列中的 pull 的概念）。而不是上游把大量的消息一股脑灌给下游消费方，然后阻塞式等待，throttling(节流) is done programmatically rather than blocking threads。

- **Non-blocking**：数据处理以一种非阻塞的方式被处理，线程不会因为等待别的处理过程而卡住。这里可以对比有着 非阻塞事件循环 的 Node.js Server（如一条高速公路）和传统的 Java 多线程服务（如拥有红绿灯的十字路口）
