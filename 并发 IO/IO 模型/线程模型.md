# 线程模型

在[《Linux 线程模型》](https://ng-tech.icu/Linux-Series/#/)中我们讨论过 Linux 中线程的实现以及用户态线程与内核态线程中等概念，在这里我们讨论的线程模型，则着眼于如何高效的利用多个物理核，进行工作任务的调度，使得系统能够有更高有效的吞吐，更加低的延迟。而不是被某个等待 IO 的线程阻塞或者把时间花在大量的比如系统层面的上下文切换等工作。网络 IO 中最简单的就是连接独占模型：也就是一个连接进来请求后，独占一个线程（进程）进行处理；无论其中中间在做什么事情，比如调用第三方的服务，等待过程中也是独占着整个线程。传统的如 Tomcat Servlet 就是基于这样的原理。而我们现在实际应用中常用的是 Reactor 模型，单线程 Reactor 模型譬如使用单个线程处理所有连接上的请求，使用 epoll-wait 方式，实现事件多路复用机制；典型比如 Redis，适用于简单比如小数据的内存数据的获取。每一个回调逻辑都比较简单。还有多线程 Reactor 模型，即多个线程/进程 Accept 同一个连接上的请求。

# Reactor 模型

## 单线程模型

所有的 IO 操作都在同一个 NIO 线程上面完成，NIO 线程需要处理客户端的 TCP 连接，同时读取客户端 Socket 的请求或者应答消息以及向客户端发送请求或者应答消息。如下图：

![Reactor 单线程模型](https://i.postimg.cc/cLws0kS8/1fdcd36e76359339539a507278f566d7.png)

由于采用的是非阻塞的 IO，所有 IO 操作都不会导致阻塞，从理论上来说，一个线程可以独立处理所有的 IO 相关操作，处理流程如下:

![Reactor 单线程模型时序图](https://i.postimg.cc/zfNqBwz2/65cdba67cfcee3302b88d114e2fd5baf.png)

可以看出，单线程模型只适用并发量比较小的应用场景。当一个 NIO 线程同时处理上万个连接时，处理速度会变慢，会导致大量的客户端连接超时，超时之后如果进行重发，更加会加重了 NIO 线程的负载，最终会有大量的消息积压和处理超时，NIO 线程会成为系统的瓶颈。

## 多线程模型

多线程模型与单线程模型最大的区别是有专门的一组 NIO 线程处理 IO 操作，一般使用线程池的方式实现。一个 NIO 线程同时处理多条连接，一个连接只能属于 1 个 NIO 线程，这样能够防止并发操作问题。

![Reactor 多线程模型](https://i.postimg.cc/s2JsZB1j/fbd2af5606580061718cb69254f95a71.png)

## 主从多线程模型

服务端用于接收客户端连接的不是 1 个单独的 NIO 线程了，而是采用独立的 NIO 线程池。Acceptor 接收 TCP 连接请求处理完成之后，将创建新的 SocketChannel 注册到处理连接的 IO 线程池中的某个 IO 线程上，有它去处理 IO 读写以及编解码的工作。Acceptor 只用于客户端登录、握手以及认证，一旦连接成功之后，将链路注册到线程池的 IO 线程上。

![Reactor 主从多线程模型](https://i.postimg.cc/SsNqLyzW/e774d586cd02cf2d4e7adba4b8300eac.png)

# 编程模型与协程

在进程，线程与协程的对比中我们讨论过协程的优劣，在上面讨论的多种线程模型中，我们仍然面临着一个问题，就是避免在如上回调逻辑中调用阻塞性的逻辑，否则单个事件被阻塞后整个线程组都会被阻塞。比如 Nginx 针对磁盘 IO 推出多线程支持，在 Nginx 中磁盘 IO 层面的请求，不直接由网络 IO 处理线程来进行，而是将磁盘 IO 的阶段委派给专门的单独的线程池进行；譬如使用 proxy_temp_file 从后端拉数据缓存在本地磁盘消费。

在 BIO 模型中，主要依赖多开线程的方式来提供服务端的吞吐。但是多开线程势必带来的问题就是系统层面的开销比较大（contex-switch、cache-bounding 等等），对于高性能场景典型就不太适用。如前所介绍的 Reactor 模型，我们天然地会引入多线程来解决这个问题；但是并发编程，特别是 1 个请求需要请求 N 个模块完成的情况下，如果使用异步模式，程序的复杂度就会非常复杂，并且很难于进行测试。对于异步代码的测试与正确性保障从来都是令人头疼的问题。

因此在编程模型中，我们倾向于使用类似于协程的解法；即在阻塞情况下保留当前 task 执行的上线文(栈、寄存器、signal 等)，然后切换到别的可以执行的 task 上。在 task 具备执行条件的时候将当前执行线程的 context 替换为为对应的 task 中保存的上下文，从而实现执行逻辑的切换。

- N:1 用户态线程库模型: N 个用户态下线程对应 1 个 native 的 thread，如腾讯开源的 libco 等。

- M:N 用户态线程库模型：典型如 go 语言的 goroutine、brpc 的 bthread、开源实现 libgo，并且支持 work-steal 的调度模型来避免长尾效应。
