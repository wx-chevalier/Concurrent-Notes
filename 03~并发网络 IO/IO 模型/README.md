# IO 模型

## IO 模型的分类

### 传统分类（Unix 网络编程）

- **阻塞 IO**：最传统的 IO 模型，进程发起 IO 请求后一直等待数据，期间无法执行其他操作
- **非阻塞 IO**：进程发起 IO 请求后立即返回，通过轮询方式检查数据是否就绪
- **IO 复用**：通过单个线程监视多个 IO 事件（如 select、poll、epoll），实现一个线程管理多个 IO 操作
- **信号驱动 IO**：进程发起 IO 请求后，系统数据就绪时以信号方式通知进程
- **异步 IO**：进程发起 IO 请求后立即返回，系统数据复制完成后通知进程，期间进程可执行其他任务

### POSIX 标准分类

- **同步 IO**：IO 操作需要进程参与等待或主动查询，直到操作完成
- **异步 IO**：进程发起 IO 请求后可以执行其他任务，IO 操作完全由系统完成并通知进程

## IO 操作的两个步骤

1. **发起 IO 请求**：应用程序向操作系统发起系统调用
2. **实际的 IO 读写**：将数据从内核空间拷贝到用户空间

### 阻塞与非阻塞的区别

- **阻塞 IO**：
  - 发起请求后进程被挂起
  - 直到数据就绪才返回
  - 适用于响应时间要求不高的场景
- **非阻塞 IO**：
  - 发起请求后立即返回
  - 需要轮询检查数据是否就绪
  - 适用于实时性要求较高的场景

### 同步与异步的区别

- **同步 IO**：
  - 需要进程参与数据拷贝过程
  - IO 状态为"读写就绪"时进程仍需要等待
  - 包含多种具体实现模型
- **异步 IO**：
  - 进程完全不参与数据拷贝
  - IO 状态为"读写完成"时数据已就绪
  - 效率最高但实现复杂

## IO 的其他分类维度

### 按数据块大小

- **大块 IO**：
  - 一次读取大量连续扇区（64、128 等）
  - 适合大文件传输
  - 提高数据吞吐量
- **小块 IO**：
  - 一次读取少量扇区（4、8 等）
  - 适合小文件或零散数据
  - 响应更快但总体效率较低

### 按访问方式

- **连续 IO**：
  - 操作的扇区地址连续或相近
  - 磁头移动距离小
  - 性能较好
- **随机 IO**：
  - 操作的扇区地址分散
  - 需要频繁移动磁头
  - 性能较差

### 按执行顺序

- **顺序 IO**：
  - 串行执行 IO 操作
  - 实现简单
  - 适用于单磁盘系统
- **并发 IO**：
  - 同时执行多个 IO 操作
  - 提高系统吞吐量
  - 适用于 RAID 等多磁盘系统
