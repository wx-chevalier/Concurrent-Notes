# 同步与安全

同步指的是线程之间的协作配合，以共同完成某个任务。在整个过程中，需要注意两个关键点：一是共享资源的访问，二是访问资源的顺序。通过前面的介绍，我们已经知道了如何让多个线程访问共享资源，但并没介绍如何控制访问顺序，才不会出现错误。如果两个线程同时访问同一内存地址的数据，一个写，一个读，如果不加控制，写线程只写了一半，读线程就开始读，必然读到的数据是错误的，不可用的，从而造成程序错误，这就造成了并发安全问题，为此我们必须要有一套控制机制来避免这样的事情发生。

# 线程安全

线程安全性是并发代码最重要也是最基本的要求，我们不应容忍大部分时候可以正确运行，但是在偶然情况下会出错的并发程序。多线程的核心矛盾即为**竞态条件**，即多个线程同时读写某个字段；而竞态条件下多线程争抢的资源就是**竞态资源**，或者说是**临界资源**。**临界区**即是设计读写竞态资源的代码片。线程如果都各自干活互不搭理的话自然相安无事，但多数情况下线程直接需要打交道，而且需要分享共享资源，那么这个时候最核心的就是线程安全了。当多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替运行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获取正确的结果，那这个对象是线程安全的。

上文已经提到，共享可变状态是造成线程不安全的唯一原因，那么为了解决线程安全性问题，可以先从避免共享状态或者避免可变状态入手。所有的线程安全性问题，都可以归结于同一个原因: 共享的可变状态。首先来看状态的共享，在 Java 中，如果类的某个域被声明为 public，或者通过 public 方法返回了某个 private 域的引用，那么这个域就可以被其它对象访问到，可以认为基于该类创建的对象，共享了其状态。一旦状态被共享，宿主对象就失去了状态的完全控制权，你无法预知其它对象会对共享状态做怎样的误操作。状态的可变性问题则来源于我们将在内存模型章节讨论的可见性、原子性与有序性问题。
