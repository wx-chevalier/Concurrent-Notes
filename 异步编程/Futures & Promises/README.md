# Futures & Promises

Futures 和 Promises 是异步编程的一种流行抽象，尤其是在分布式系统的情况下。考虑一下简单的计算机处理器；没有并行性，只有一次完成一项任务或流程的能力。在这种情况下，有时在调用某些阻塞操作时会阻塞处理器。此类阻塞调用可能包括 I/O 操作，例如读/写磁盘，或通过网络发送或接收数据包。而且作为程序员，我们知道像 I/O 这样的阻塞调用要比典型的 CPU 绑定任务（如遍历列表）花费更多的时间。

处理器可以通过两种方式处理阻塞呼叫：

- 同步：处理器等待，直到阻塞调用完成其任务并返回结果。之后，处理器将继续处理下一个任务。这有时可能会引起问题，因为可能无法有效利用 CPU。它可能会等待很长时间。

- 异步：当异步处理任务时，在同步情况下等待所花费的 CPU 时间改为使用抢占式时间共享算法来处理其他任务。也就是说，不是等待，而是处理其他任务。因此，只要有更多工作可以完成，处理器就永远不会等待。

在编程领域，为了帮助程序员达到理想的资源利用率水平，引入了许多构造；Futures 与 Promises 即使其中最为广泛使用的概念之一。

# 基础概念

正如我们将在后续章节中看到的那样，我们选择称其为“概念”，其确切定义往往会有所不同。我们将从对 Futures/Promises 的概念的尽可能广泛的定义开始，然后放大并涵盖不同语言对这些构造的解释之间的许多语义差异。一个 Future 或者 Promise 可以看做那些暂时不可得但是最终会被得到的值。换句话说，它是对时间概念进行编码的抽象。通过选择使用此构造，可以假定您的值现在可以具有许多可能的状态，具体取决于我们请求它的时间点。最简单的变化包括两个与时间有关的状态：

- completed/determined：计算完毕，可以获得值。
- incomplete/undetermined：计算还在进行中。

稍后我们将看到，在 Futures/Promises 的某些变体中引入了其他状态，以更好地支持错误处理和取消之类的需求。重要的是，Futures/Promises 通常可以实现一定程度的并发。也就是说，在 Futures 的第一个定义中：

> The construct ( future X ) immediately returns a future for the value of the expression X and concurrently begins evaluating X. When the evaluation of X yields a value, that value replaces the future.
>
> - (Halstead, 1985)

Futures/Promises 的某些解释具有与之相关的类型，而另一些则没有。通常，未来/承诺是单项任务；也就是说，它只能被写入一次。一些解释是阻塞的（同步的），另一些则是完全非阻塞的（异步的）。某些解释必须显式启动（即手动启动），而在其他解释中，计算是隐式启动的。受函数编程的启发，此构造的不同解释之间的主要区别之一与流水线或组合有关。对 Futures/Promises 的一些较流行的解释使链接操作或定义在完成由 Futures/Promises 表示的计算时要调用的操作的流水线成为可能。这与大量使用回调或更强制性的直接阻止方法形成对比。

## 源起与应用

作为相关主题的 Futures & Promises 的兴起在很大程度上与并行和并发编程以及分布式系统的兴起同时发生。这自然而然地遵循，因为作为对时间进行编码的抽象，当延迟成为问题时，Futures & Promises 引入了一种很好的方式来推断状态变化；当一个节点必须与分布式系统中的另一个节点进行通信时，程序员通常会面临这些问题。但是，Futures & Promises 在许多其他情况下也被认为是有用的，无论是分布式的还是无用的。此类上下文包括：

- Request-Response Patterns，例如通过 HTTP 的网络服务调用。Futures 可以用来表示 HTTP 请求的响应值。

- Input/Output，例如需要用户输入的 UI 对话框，或例如从磁盘读取大文件的操作。Futures 可以用来表示 IO 调用和 IO 的结果值（例如，终端输入，已读取文件的字节数组）。

- Long-Running Computations，想象一下，您希望启动长时间运行的计算（例如复杂的数值算法）的过程不要等待该长时间运行的计算完成，而是继续处理其他任务。未来可能会用来表示这种长期运行的计算及其结果的价值。

- Database Queries，像长时间运行的计算一样，数据库查询可能很耗时。 因此，像上面一样，可能希望将执行查询的工作转移到另一个进程，然后继续处理下一个任务。 Futures 可以用来表示查询和查询的结果值。

- RPC (Remote Procedure Call)，当对服务器进行 RPC 调用时，网络延迟通常是一个问题。 像上面一样，可能希望不必等待 RPC 调用的结果，而只需将其卸载到另一个进程即可。 Futures 可以用来表示 RPC 调用及其结果。 当服务器响应结果时，Futures 就完成了，其价值就是服务器的响应。

- Reading Data from a Socket 可能由于网络延迟而非常耗时。 因此，可能希望不必等待传入的数据，而是将其卸载到另一个进程。 Futures 可以用来表示读取操作以及 Futures 完成时读取的结果值。

- Timeouts，例如管理 Web 服务中的超时。 表示超时的 Future 可能只返回没有结果或某种空结果，例如类型化编程语言中的 Unit 类型。

今天，许多现实世界中的服务和系统都在诸如此类的流行环境中大量使用 Futures/Promises，这要归功于对未来的看法或对诸如 JavaScript，Node.js，Scala，Java，C++等流行语言和框架的承诺。正如我们将在其他章节中看到的那样，Futures/Promises 的这种扩散导致 Futures/Promises 随着时间和跨语言而改变了含义和名称。

## 相似概念梳理

Future, Promise, Delay 以及 Deferred 通常指的是大致相同的同步机制，其中对象充当迄今未知结果的代理。当结果可用时，然后执行其他一些代码。多年来，这些术语已指代语言和生态系统之间略有不同的语义。在部分语言中，可能直接存在像 Future, Promise, Delay 以及 Deferred 这样的类或可构造函数。

# 简史

如下的时间轴是对于 Futures & Promises 的简史的梳理：

![History](https://s1.ax1x.com/2020/03/30/GuWM8A.md.png)
