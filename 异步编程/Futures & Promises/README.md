# Futures & Promises

Futures 和 Promises 是异步编程的一种流行抽象，尤其是在分布式系统的情况下。考虑一下简单的计算机处理器； 没有并行性，只有一次完成一项任务或流程的能力。在这种情况下，有时在调用某些阻塞操作时会阻塞处理器。此类阻塞调用可能包括 I/O 操作，例如读/写磁盘，或通过网络发送或接收数据包。而且作为程序员，我们知道像 I/O 这样的阻塞调用要比典型的 CPU 绑定任务（如遍历列表）花费更多的时间。

处理器可以通过两种方式处理阻塞呼叫：

- 同步：处理器等待，直到阻塞调用完成其任务并返回结果。之后，处理器将继续处理下一个任务。这有时可能会引起问题，因为可能无法有效利用 CPU。它可能会等待很长时间。

- 异步：当异步处理任务时，在同步情况下等待所花费的 CPU 时间改为使用抢占式时间共享算法来处理其他任务。也就是说，不是等待，而是处理其他任务。因此，只要有更多工作可以完成，处理器就永远不会等待。

在编程领域，为了帮助程序员达到理想的资源利用率水平，引入了许多构造；Futures 与 Promises 即使其中最为广泛使用的概念之一。

# 基础概念

正如我们将在后续章节中看到的那样，我们选择称其为“概念”，其确切定义往往会有所不同。 我们将从对 Futures/Promises 的概念的尽可能广泛的定义开始，然后放大并涵盖不同语言对这些构造的解释之间的许多语义差异。一个 Future 或者 Promise 可以看做那些暂时不可得但是最终会被得到的值。换句话说，它是对时间概念进行编码的抽象。 通过选择使用此构造，可以假定您的值现在可以具有许多可能的状态，具体取决于我们请求它的时间点。 最简单的变化包括两个与时间有关的状态：

- completed/determined：计算完毕，可以获得值。
- incomplete/undetermined：计算还在进行中。

稍后我们将看到，在 Futures/Promises 的某些变体中引入了其他状态，以更好地支持错误处理和取消之类的需求。重要的是，Futures/Promises 通常可以实现一定程度的并发。 也就是说，在 Futures 的第一个定义中：

> The construct ( future X ) immediately returns a future for the value of the expression X and concurrently begins evaluating X. When the evaluation of X yields a value, that value replaces the future.
>
> - (Halstead, 1985)

Futures/Promises 的某些解释具有与之相关的类型，而另一些则没有。 通常，未来/承诺是单项任务； 也就是说，它只能被写入一次。 一些解释是阻塞的（同步的），另一些则是完全非阻塞的（异步的）。 某些解释必须显式启动（即手动启动），而在其他解释中，计算是隐式启动的。

受函数编程的启发，此构造的不同解释之间的主要区别之一与流水线或组合有关。 对 Futures/Promises 的一些较流行的解释使链接操作或定义在完成由 Futures/Promises 表示的计算时要调用的操作的流水线成为可能。 这与大量使用回调或更强制性的直接阻止方法形成对比。
