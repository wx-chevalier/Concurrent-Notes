# 执行语义

随着这些年来架构和运行时的发展和变化，实现 futures/promises 的技术也是如此，以至于抽象化转化为系统资源的有效利用。在本节中，我们将介绍三种主要执行模型，在这些模型上以流行的语言和库为基础构建 futures/promises。也就是说，我们将看到 futures 和 promises 在其 API 下实际执行和解决的不同方式。

# Thread Pools

线程池是一种使用户可以访问可以进行工作的一组就绪的空闲线程的抽象。线程池的实现会照顾到工作线程的创建，管理和调度，如果不小心处理，它们很容易变得棘手且代价高昂。线程池具有许多不同的风格，具有许多用于调度和执行任务的技术，并且具有固定数量的线程，或者具有根据负载动态调整自身大小的能力。Java 的 Executor 就是典型的线程池的实现，Executor 包含了一系列 Runnable 的任务，它对上屏蔽了任务具体执行细节的抽象。这些详细信息（例如选择运行任务的线程，任务的计划方式）由 Executor 接口的基础实现管理。

类似于 Executor，Scala 在 `scala.concurrent` 包中提供了 ExecutionContext 类，其基础的特性类似于 Java 的 Executor；它负责并发高效地执行计算，而无需池中的用户去担心诸如调度之类的事情。更重要地是，ExecutionContext 同样可被当做接口，我们能够改变线程池地底层实现而保证上层接口的一致性。在诸多的实现中，Scala 的默认 ExecutionContext 的实现是基于 Java 的 ForkJoinPool，一种具有 work-stealing 算法的线程池实现，其中空闲线程拾取先前安排给其他繁忙线程的任务。ForkJoinPool 是一种流行的线程池实现，因为它比 Executors 的性能有所提高，能够更好地避免池引起的死锁，并最大程度地减少了在线程之间切换所花费的时间。

Scala 的 futures & promsies 就是基于 ExecutionContext，虽然通常用户使用由 ForkJoinPool 支持的基础默认 ExecutionContext，但如果用户需要特定行为（例如阻止 futures），他们还可以选择提供（或实现）自己的 ExecutionContext。n Scala，对 Future 或 Promise 的每次使用都需要传递某种 ExecutionContext。此参数是隐式的，通常是 ExecutionContext.global（默认的基础 ForkJoinPool ExecutionContext）。例如，创建并运行一个基本的 future：

```scala
implicit val ec = ExecutionContext.global
val f : Future[String] = Future { “hello world” }
```

在此示例中，全局执行上下文用于异步运行所创建的 Future。如前所述，Future 的 ExecutionContext 参数是隐式的。这意味着，如果编译器在所谓的隐式范围内找到 ExecutionContext 的实例，则它将自动传递给对 Future 的调用，而用户不必显式传递它。在上面的示例中，在声明 ec 时使用隐式关键字将 ec 置于隐式范围内。如前所述，Scala 中的 Future 和 Promise 是异步的，这是通过使用回调实现的。例如：

```scala
implicit val ec = ExecutionContext.global

val f = Future {
  Http("http://api.fixed.io/latest?base=USD").asString
}

f.onComplete {
  case Success(response) => println(response)
  case Failure(t) => println(t.getMessage())
}
```

在此示例中，我们首先创建一个 Future f，然后当它完成时，我们提供两个可能的表达式，这些表达式可以根据 Future 是否成功执行或是否有错误来调用。在这种情况下，如果成功，我们将获得计算结果的 HTTP 字符串，并将其打印出来。如果引发了异常，我们将获取包含在异常中的消息字符串并进行打印。那么，它们如何一起工作？

如前所述，Future 需要一个 ExecutionContext，这是几乎所有 Future API 的隐式参数。此 ExecutionContext 用于执行将来。Scala 足够灵活，可以让用户实现自己的 ExecutionContext，但是让我们谈谈默认的 ExecutionContext，它是一个 ForkJoinPool。ForkJoinPool 非常适合生成许多小计算然后又重新组合在一起的小型计算。Scala 的 ForkJoinPool 要求提交给它的任务是 ForkJoinTask。提交给全局 ExecutionContext 的任务被安静地包装在 ForkJoinTask 中，然后执行。ForkJoinPool 还使用 ManagedBlock 方法来支持可能的阻塞任务，该方法将在需要时创建备用线程，以确保在当前线程被阻塞时确保足够的并行度。总而言之，ForkJoinPool 是一个非常好的通用 ExecutionContext，它在大多数情况下都非常有效。
